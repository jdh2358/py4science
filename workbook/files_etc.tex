\section{Working with files, the web, arrays, etc\dots}
\label{sec:working_with_files}

This section is a general overview to show how easy it is to load
and manipulate data on the file system and over the web using python's
built in data structures and numpy arrays.  The goal is to exercise
basic programming skills like building filename or web addresses to
automate certain tasks like loading a series of data files or
downloading a bunch of related files off the web, as well as to
illustrate basic numpy and pylab skills.

\subsection{Loading and saving ASCII data}
\label{sec:ascii_data}

The simplest file format is a plain text ASCII file of numbers.
Although there are many better formats out there for saveing and
loading data, this format is extremely common because it has the
advantages of being human readable, and thus will survive the test of
time as the \textit{en vogue} programming languages, analysis
applications and data formats come and go, it is easy to parse, and it
is supported by almost all languages and applications.  

In this exercise we will create a data set of two arrays, the first
one regularly sampled time \textit{t} from 0..2 seconds with 20~ms
time step , and the second one an array \texttt{v} of sinusoidal
voltages corrupted by some noise.  Let's assume the sine wave has
amplitude 2~V, frequency 10~Hz, and zero mean Gaussian distrubuted
white noise with standard deviation 0.5~V.  Your task is to write two
scripts.

The first script should create the vectors \texttt{t} and \texttt{v},
plot the time series of \texttt{t} versus \texttt{v}, save them in a
two dimensional numpy array \texttt{X}, and then dump the array
\texttt{X} to a plain text ASCII file called
\texttt{'noisy_sine.dat'}.  The file will look like (not identical
because of the noise)

\begin{verbatim}
0.000000000000000000e+00 1.550947826934816025e-02
2.000000000000000042e-02 2.493944587057004725e+00
4.000000000000000083e-02 9.497694074551737975e-01
5.999999999999999778e-02 -9.185779287524413750e-01
8.000000000000000167e-02 -2.811127590689064704e+00
... and so on
\end{verbatim}

Here is the exercise skeleton of the script to create and plot the
data file

\lstinputlisting[label=code:noisy_sine_skel,caption={IGNORED}]{skel/noise_sine_skel.py}

and the graph will look something like Figure~\ref{fig:noisy_sine}

\begin{center}%
\begin{figure}
\begin{centering}\includegraphics[width=4in]{fig/noise_sine}\par\end{centering}


\caption{\label{fig:noisy_sine}A 10~Hz sine wave corrupted by noise}
\end{figure}
\par\end{center}

The second part of this exercise is to write a script which loads data
from the data file into an array \texttt{X}, extracts the columns into
arrays \texttt{t} and \texttt{v}, and computes the RMS
(root-mean-square) intensity of the signal using the \textt{load}
command.


\subsection{Loading and saving binary data}
\label{sec:binary_data}

ASCII is bloated and slow for working with large arrays, and so binary
data should be used if performance is a consideration.  To save the
array \texttt{X} in binary form, use the numpy \texttt{tostring} method

\begin{lstlisting}
# open the file for writing binary and write the binary string
file('../data/binary_data.dat', 'wb').write(X.tostring())
\end{lstlisting}

\noindent This data can later be loaded into a numpy array using
\texttt{fromstring}.  This method takes two arguments, a string and a
data type (note that numarray users can use \texttt{fromfile} which is
more efficient for importing data directly from a file).  

\lstinputlisting{code/load_binary_data.py}

\noindent Note that although Numpy and numarray use different
typecode arguments (Numeric uses strings whereas numarray uses type
objects), the matplotlib.numpy compatibility layer provides symbols
which will work with either \rc{numpy} rc setting.

\subsection{Processing several data files}
\label{sec:multiple_files}

Since python is a programming language \textit{par excellence}, it is
easy to process data in batch.  When I started the gradual transition
from a full time \matlab\ user to a full time python user, I began
processing my data in python and saving the results to data files for
plotting in \matlab.  When that became too cumbersome, I decided to
write matplotlib so I could have all the functionality I needed in one
environment.  Here is a brief example showing how to iterate over
several data files, named \fname{basename001.dat, basename002.dat,
  basename003.dat, ... basename100.dat} and plot all of the traces to
the same axes.  I'll assume for this example that each file is a 1D
ASCII array, which I can load with the \texttt{load} command.

\begin{lstlisting}
hold(True)  # set the hold state to be on
for i in range(1,101):  #start at 1, end at 100
    fname = 'basename%03d.dat'%i  # %03d pads the integers with zeros
    x = load(fname)
    plot(x)
\end{lstlisting}


